注意:
    FairLock中的lock方法中有两个同步模块，A 线程执行之后isLocked=true，导致 B 线程进来会执行wait(),但是外层的同步
块不会被释放，导致 B 处于阻塞状态并持有外层同步块this; 所有A线程继续执行unlock()时会处于阻塞，由于B没有释放this

管程死锁 VS 死锁
   1. 死锁中，二个线程都在等待对方释放锁。
   2. 嵌套管程锁死中，线程1持有锁A，同时等待从线程2发来的信号，线程2需要锁A来发信号给线程1。