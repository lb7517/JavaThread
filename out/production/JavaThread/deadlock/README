(可能)死锁的例子:
前提是: 两个线程中的parent,children表示的是同一个对象
    线程A 执行parent.addChildren(children); 由于addChild是同步模块，parent对象会被锁住， 在执行children.setParentOnly();可能
获取不到children对象导致死锁
    线程B 执行children.setParent(parent);   由于setParent是同步模块，children对象会被锁住，在执行 parent.addChildOnly(this);
可能获取不到parent对象锁导致死锁


注意: 避免死锁的方式有
    1. 加锁顺序  线程1: lock A, lock B; 线程2: wait for A, lock C(when A locked); 线程3: wait for A, wait for B, wait for C;
按照此顺序执行可以防止死锁，缺点是事先要知道执行顺序
    2. 加锁时限 给锁添加获取超时时间，超时放弃所有拥有的锁，等待一段时间再去请求 (超时和重试机制是为了避免在同一时间出现的
竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时
间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题); 在Java中不能对synchronized同步块设置超时时间
    3. 死锁检测
    a. 一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似(，但是如果有大量的线程竞争
同一批锁，它们还是会重复地死锁)
    b.一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。
如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优
先级